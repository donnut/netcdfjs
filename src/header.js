// Generated by CoffeeScript 1.9.1
var Header, Lexer, constants, roundup,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Lexer = require('./lexer');

constants = require('./constants');

roundup = function(num, multiple) {
  var remainder;
  if (multiple === 0) {
    return num;
  }
  remainder = num % multiple;
  if (remainder === 0) {
    return num;
  }
  return num + multiple - remainder;
};

Header = (function() {
  function Header(data) {
    this["var"] = bind(this["var"], this);
    this.var_list = bind(this.var_list, this);
    this.attr = bind(this.attr, this);
    this.att_list = bind(this.att_list, this);
    this.vatt_list = bind(this.vatt_list, this);
    this.gatt_list = bind(this.gatt_list, this);
    this.name = bind(this.name, this);
    this.dim = bind(this.dim, this);
    this.dim_list = bind(this.dim_list, this);
    this.numrecs = bind(this.numrecs, this);
    this.magic = bind(this.magic, this);
    this.precompute_size = bind(this.precompute_size, this);
    this.precompute = bind(this.precompute, this);
    this.header = bind(this.header, this);
    this.lex = new Lexer(data);
  }

  Header.prototype.header = function() {
    return this.precompute({
      version: this.magic(),
      records: this.numrecs(),
      dimensions: this.dim_list(),
      attributes: this.gatt_list(),
      variables: this.var_list()
    });
  };

  Header.prototype.precompute = function(header) {
    var _, dim, j, len, ref, ref1, ref2, ref3, ref4, v;
    ref = header.dimensions;
    for (j = 0, len = ref.length; j < len; j++) {
      dim = ref[j];
      if (dim.length === null) {
        header.records.dimension = dim.index;
        break;
      }
    }
    ref1 = header.variables;
    for (_ in ref1) {
      v = ref1[_];
      this.precompute_size(v, header);
    }
    header.hassinglerecord = false;
    ref2 = header.variables;
    for (_ in ref2) {
      v = ref2[_];
      if (v.isrecord) {
        if (header.hassinglerecord) {
          header.hassinglerecord = false;
          break;
        }
        header.hassinglerecord = true;
      }
    }
    if (!header.hassinglerecord) {
      ref3 = header.variables;
      for (_ in ref3) {
        v = ref3[_];
        v.size = roundup(v.size, 4);
      }
    }
    header.recordsize = 0;
    ref4 = header.variables;
    for (_ in ref4) {
      v = ref4[_];
      if (!v.isrecord) {
        continue;
      }
      header.recordsize += v.size;
    }
    return header;
  };

  Header.prototype.precompute_size = function(variable, header) {
    var indexes, j, product, products, ref, results, size, sizes;
    indexes = variable.dimensions;
    variable.dimensions = {
      indexes: indexes,
      sizes: [],
      products: []
    };
    if (indexes.length === 0) {
      return;
    }
    product = 1;
    products = (function() {
      results = [];
      for (var j = ref = indexes.length - 1; ref <= 0 ? j <= 0 : j >= 0; ref <= 0 ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map(function(i) {
      var index;
      index = indexes[i];
      product *= header.dimensions[index].length;
      return product;
    });
    products = products.reverse();
    variable.dimensions.products = products;
    sizes = products.map(function(p) {
      return p * variable.size;
    });
    variable.dimensions.sizes = products.map((function(_this) {
      return function(p) {
        return p * _this.lex.sizeForType(variable.type);
      };
    })(this));
    variable.isrecord = header.dimensions[indexes[0]].length === null;
    size = this.lex.sizeForType(variable.type);
    if (variable.dimensions.indexes.length < 2) {
      return variable.size = size;
    }
    size = variable.isrecord ? variable.dimensions.sizes[1] : variable.dimensions.sizes[0];
    return variable.size = size;
  };

  Header.prototype.magic = function() {
    var description, magicstring, version;
    magicstring = this.lex.string(3);
    if (magicstring !== 'CDF') {
      throw new Error('Not a valid NetCDF file ' + magicstring);
    }
    version = this.lex.byte();
    if (version !== 1 && version !== 2 && version !== 3) {
      throw new Error("Unknown NetCDF format (version " + version + ")");
    }
    if (version === 1) {
      description = 'Classic format';
    }
    if (version === 2) {
      description = '64 bit offset format';
    }
    return {
      number: version,
      description: description
    };
  };

  Header.prototype.numrecs = function() {
    var numrecs;
    if (this.lex.match(constants.streamingMarker)) {
      this.lex.forward(constants.streamingMarker.length);
      return {
        type: 'streaming'
      };
    } else {
      numrecs = this.lex.uint32();
      return {
        type: 'fixed',
        number: numrecs
      };
    }
  };

  Header.prototype.dim_list = function() {
    var count, j, results;
    if (this.lex.match(constants.zeroMarker)) {
      console.log('no dimensions');
      this.lex.forward(8);
      return {};
    }
    if (!this.lex.match(constants.dimensionMarker)) {
      throw new Error('Dimension marker not found');
    }
    this.lex.forward(constants.dimensionMarker.length);
    count = this.lex.uint32();
    if (count === 0 && this.lex.uint32() !== constants.zeroMarker) {
      throw new Error('No dimensions and no absent marker present');
    }
    return (function() {
      results = [];
      for (var j = 0; 0 <= count ? j < count : j > count; 0 <= count ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map((function(_this) {
      return function(index) {
        var res;
        res = _this.dim();
        res.index = index;
        return res;
      };
    })(this));
  };

  Header.prototype.dim = function() {
    var dim, ref;
    dim = {
      name: this.name(),
      length: (ref = this.lex.uint32()) != null ? ref : 0
    };
    if (dim.length === 0) {
      dim.length = null;
    }
    return dim;
  };

  Header.prototype.name = function() {
    var length, res;
    length = this.lex.uint32();
    res = this.lex.string(length);
    this.lex.fill(length);
    return res;
  };

  Header.prototype.gatt_list = function() {
    return this.att_list();
  };

  Header.prototype.vatt_list = function() {
    return this.att_list();
  };

  Header.prototype.att_list = function() {
    var attr, count, j, ref, res;
    if (this.lex.match(constants.zeroMarker)) {
      this.lex.forward(8);
      return {};
    }
    if (!this.lex.match(constants.attributeMarker)) {
      throw new Error('Attribute marker not found');
    }
    this.lex.forward(constants.attributeMarker.length);
    count = this.lex.uint32();
    if (count === 0 && this.lex.uint32() !== constants.zeroMarker) {
      throw new Error('No attributes and no absent marker present');
    }
    res = {};
    for (j = 0, ref = count; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
      attr = this.attr();
      res[attr.name] = attr.value;
    }
    return res;
  };

  Header.prototype.attr = function() {
    return {
      name: this.name(),
      value: this.lex.readerForType(this.lex.type())(this.lex.uint32())
    };
  };

  Header.prototype.var_list = function() {
    var count, j, ref, res, variable;
    if (this.lex.match(constants.zeroMarker)) {
      this.lex.forward(constants.zeroMarker.length);
      return {};
    }
    if (!this.lex.match(constants.variableMarker)) {
      throw new Error('Variable marker not found');
    }
    this.lex.forward(constants.variableMarker.length);
    count = this.lex.uint32();
    if (count === 0 && this.lex.uint32() !== constants.zeroMarker) {
      throw new Error('No variables and no absent marker present');
    }
    res = {};
    for (j = 0, ref = count; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
      variable = this["var"]();
      res[variable.name] = variable.value;
    }
    return res;
  };

  Header.prototype["var"] = function() {
    var j, ref, results;
    return {
      name: this.name(),
      value: {
        dimensions: (function() {
          results = [];
          for (var j = 0, ref = this.lex.uint32(); 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this).map((function(_this) {
          return function() {
            return _this.lex.uint32();
          };
        })(this)),
        attributes: this.vatt_list(),
        type: this.lex.type(),
        size: this.lex.uint32(),
        offset: this.lex.uint32()
      }
    };
  };

  return Header;

})();

module.exports = Header;
