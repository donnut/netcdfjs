// Generated by CoffeeScript 1.8.0
var Lexer, TextDecoder, constants, decoder, match,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

TextDecoder = require('text-encoding').TextDecoder;

decoder = new TextDecoder('utf-8');

constants = require('./constants');

match = function(data, index, bytes) {
  var i, _i, _ref;
  if (index + bytes.length > data.length) {
    return false;
  }
  for (i = _i = 0, _ref = bytes.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (bytes[i] !== data[index + i]) {
      return false;
    }
  }
  return true;
};

module.exports = Lexer = (function() {
  function Lexer(data) {
    this.reader = __bind(this.reader, this);
    this.doubles = __bind(this.doubles, this);
    this.floats = __bind(this.floats, this);
    this.ints = __bind(this.ints, this);
    this.shorts = __bind(this.shorts, this);
    this.bytes = __bind(this.bytes, this);
    this.chars = __bind(this.chars, this);
    this.type = __bind(this.type, this);
    this.double = __bind(this.double, this);
    this.float = __bind(this.float, this);
    this.uint64 = __bind(this.uint64, this);
    this.uint32 = __bind(this.uint32, this);
    this.uint16 = __bind(this.uint16, this);
    this.uint8 = __bind(this.uint8, this);
    this.string = __bind(this.string, this);
    this.read = __bind(this.read, this);
    this.hex = __bind(this.hex, this);
    this.char = __bind(this.char, this);
    this.byte = __bind(this.byte, this);
    this.print = __bind(this.print, this);
    this.match = __bind(this.match, this);
    this.fill = __bind(this.fill, this);
    this.forward = __bind(this.forward, this);
    this.next = __bind(this.next, this);
    this.hasMore = __bind(this.hasMore, this);
    this.go = __bind(this.go, this);
    this.d = data;
    this.i = 0;
    this.n = data.length;
  }

  Lexer.prototype.go = function(i) {
    return this.i = i;
  };

  Lexer.prototype.hasMore = function() {
    return this.i < this.n;
  };

  Lexer.prototype.next = function() {
    return this.i++;
  };

  Lexer.prototype.forward = function(n) {
    return this.i += n;
  };

  Lexer.prototype.fill = function(n) {
    var b;
    b = Math.ceil(n / 4) * 4 - n;
    if (b === 0) {
      return;
    }
    return this.i += b;
  };

  Lexer.prototype.match = function(bytes) {
    return match(this.d, this.i, bytes);
  };

  Lexer.prototype.print = function(n) {
    var a, b, c, i, index, _i, _results;
    index = this.i;
    a = (function(_this) {
      return function() {
        var res;
        res = _this.d[index].toString(16);
        index++;
        if (res.length === 1) {
          return "0" + res;
        }
        return res;
      };
    })(this);
    b = function() {
      return "" + (a()) + (a()) + (a()) + (a());
    };
    c = function() {
      console.log();
      console.log("" + (b()) + " " + (b()) + " " + (b()) + " " + (b()));
      console.log("" + (b()) + " " + (b()) + " " + (b()) + " " + (b()));
      console.log("" + (b()) + " " + (b()) + " " + (b()) + " " + (b()));
      return console.log("" + (b()) + " " + (b()) + " " + (b()) + " " + (b()));
    };
    _results = [];
    for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
      _results.push(c());
    }
    return _results;
  };

  Lexer.prototype.byte = function() {
    this.next();
    return this.d[this.i - 1];
  };

  Lexer.prototype.char = function() {
    return String.fromCharCode(this.byte());
  };

  Lexer.prototype.hex = function() {
    return this.byte().toString(16);
  };

  Lexer.prototype.read = function(n) {
    if (this.i + n > this.n || n === 0) {
      return null;
    }
    this.i += n;
    return this.d.subarray(this.i - n, this.i);
  };

  Lexer.prototype.string = function(n) {
    return decoder.decode(this.read(n));
  };

  Lexer.prototype.uint8 = function() {
    this.forward(1);
    return this.d[this.i - 1];
  };

  Lexer.prototype.uint16 = function() {
    this.forward(2);
    return this.d[this.i - 2] << 8 | this.d[this.i - 1];
  };

  Lexer.prototype.uint32 = function() {
    this.forward(4);
    return this.d[this.i - 4] << 24 | this.d[this.i - 3] << 16 | this.d[this.i - 2] << 8 | this.d[this.i - 1];
  };

  Lexer.prototype.uint64 = function() {
    this.forward(8);
    return this.d[this.i - 4] << 24 | this.d[this.i - 3] << 16 | this.d[this.i - 2] << 8 | this.d[this.i - 1];
  };

  Lexer.prototype.float = function() {
    throw new Error('Not implemented');
  };

  Lexer.prototype.double = function() {
    throw new Error('Not implemented');
  };

  Lexer.prototype.type = function() {
    var rmatch;
    this.forward(4);
    rmatch = (function(_this) {
      return function(bytes) {
        return match(_this.d, _this.i - 4, bytes);
      };
    })(this);
    if (rmatch(constants.byteMarker)) {
      return 'byte';
    }
    if (rmatch(constants.charMarker)) {
      return 'char';
    }
    if (rmatch(constants.shortMarker)) {
      return 'short';
    }
    if (rmatch(constants.intMarker)) {
      return 'int';
    }
    if (rmatch(constants.floatMarker)) {
      return 'float';
    }
    if (rmatch(constants.doubleMarker)) {
      return 'double';
    }
    return null;
  };

  Lexer.prototype.chars = function(n) {
    var result;
    result = this.string(n);
    this.fill(n);
    return result;
  };

  Lexer.prototype.bytes = function(n) {
    var result, _i, _results;
    result = (function() {
      _results = [];
      for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.byte();
      };
    })(this));
    this.fill(n);
    return result;
  };

  Lexer.prototype.shorts = function(n) {
    var result, _i, _results;
    result = (function() {
      _results = [];
      for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.uint16();
      };
    })(this));
    this.fill(n * 2);
    return result;
  };

  Lexer.prototype.ints = function(n) {
    var _i, _results;
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.uint32();
      };
    })(this));
  };

  Lexer.prototype.floats = function(n) {
    var _i, _results;
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.float();
      };
    })(this));
  };

  Lexer.prototype.doubles = function(n) {
    var _i, _results;
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.double();
      };
    })(this));
  };

  Lexer.prototype.reader = function(type) {
    return this["" + type + "s"];
  };

  return Lexer;

})();
