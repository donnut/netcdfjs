// Generated by CoffeeScript 1.9.1
var Lexer, constants, decoder, match,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

decoder = new require('text-encoding').TextDecoder('utf-8');

constants = require('./constants');

match = function(data, index, bytes) {
  var i, j, ref;
  if (index + bytes.length > data.length) {
    return false;
  }
  for (i = j = 0, ref = bytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    if (bytes[i] !== data[index + i]) {
      return false;
    }
  }
  return true;
};

module.exports = Lexer = (function() {
  function Lexer(data) {
    this.reader = bind(this.reader, this);
    this.doubles = bind(this.doubles, this);
    this.floats = bind(this.floats, this);
    this.ints = bind(this.ints, this);
    this.shorts = bind(this.shorts, this);
    this.bytes = bind(this.bytes, this);
    this.chars = bind(this.chars, this);
    this.type = bind(this.type, this);
    this.double = bind(this.double, this);
    this.float = bind(this.float, this);
    this.uint64 = bind(this.uint64, this);
    this.uint32 = bind(this.uint32, this);
    this.uint16 = bind(this.uint16, this);
    this.uint8 = bind(this.uint8, this);
    this.string = bind(this.string, this);
    this.read = bind(this.read, this);
    this.hex = bind(this.hex, this);
    this.char = bind(this.char, this);
    this.byte = bind(this.byte, this);
    this.print = bind(this.print, this);
    this.match = bind(this.match, this);
    this.fill = bind(this.fill, this);
    this.backward = bind(this.backward, this);
    this.forward = bind(this.forward, this);
    this.next = bind(this.next, this);
    this.hasMore = bind(this.hasMore, this);
    this.go = bind(this.go, this);
    this.d = data;
    this.i = 0;
    this.n = data.length;
  }

  Lexer.prototype.go = function(i) {
    return this.i = i;
  };

  Lexer.prototype.hasMore = function() {
    return this.i < this.n;
  };

  Lexer.prototype.next = function() {
    return this.i++;
  };

  Lexer.prototype.forward = function(n) {
    return this.i += n;
  };

  Lexer.prototype.backward = function(n) {
    return this.i -= n;
  };

  Lexer.prototype.fill = function(n) {
    var b;
    b = Math.ceil(n / 4) * 4 - n;
    if (b === 0) {
      return;
    }
    return this.i += b;
  };

  Lexer.prototype.match = function(bytes) {
    return match(this.d, this.i, bytes);
  };

  Lexer.prototype.print = function(n) {
    var a, b, c, i, index, j, ref, results;
    index = this.i;
    a = (function(_this) {
      return function() {
        var res;
        res = _this.d[index].toString(16);
        index++;
        if (res.length === 1) {
          return "0" + res;
        }
        return res;
      };
    })(this);
    b = function() {
      return "" + (a()) + (a());
    };
    c = function() {
      console.log();
      return console.log((b()) + " " + (b()) + " " + (b()) + " " + (b()) + " " + (b()) + " " + (b()) + " " + (b()) + " " + (b()));
    };
    results = [];
    for (i = j = 1, ref = n; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push(c());
    }
    return results;
  };

  Lexer.prototype.byte = function() {
    this.next();
    return this.d[this.i - 1];
  };

  Lexer.prototype.char = function() {
    return String.fromCharCode(this.byte());
  };

  Lexer.prototype.hex = function() {
    return this.byte().toString(16);
  };

  Lexer.prototype.read = function(n) {
    if (this.i + n > this.n || n === 0) {
      return null;
    }
    this.i += n;
    return this.d.subarray(this.i - n, this.i);
  };

  Lexer.prototype.string = function(n) {
    return decoder.decode(this.read(n));
  };

  Lexer.prototype.uint8 = function() {
    this.forward(1);
    return this.d[this.i - 1];
  };

  Lexer.prototype.uint16 = function() {
    this.forward(2);
    return this.d[this.i - 2] << 8 | this.d[this.i - 1];
  };

  Lexer.prototype.uint32 = function() {
    this.forward(4);
    return this.d[this.i - 4] << 24 | this.d[this.i - 3] << 16 | this.d[this.i - 2] << 8 | this.d[this.i - 1];
  };

  Lexer.prototype.uint64 = function() {
    this.forward(8);
    return this.d[this.i - 4] << 24 | this.d[this.i - 3] << 16 | this.d[this.i - 2] << 8 | this.d[this.i - 1];
  };

  Lexer.prototype.float = function() {
    var bytes, exponent, ref, sign, significand;
    bytes = this.uint32();
    sign = (ref = bytes & 0x80000000) != null ? ref : -{
      1: 1
    };
    exponent = ((bytes >> 23) & 0xFF) - 127;
    significand = bytes & ~(-1 << 23);
    if (exponent === 128) {
      if (significand) {
        return sign * Number.NaN;
      } else {
        return sign * Number.POSITIVE_INFINITY;
      }
    }
    if (exponent === -127) {
      if (significand === 0) {
        return sign * 0.0;
      }
      exponent = -126;
      significand /= 1 << 22;
    } else {
      significand = (significand | (1 << 23)) / (1 << 23);
    }
    return sign * significand * Math.pow(2, exponent);
  };

  Lexer.prototype.double = function() {
    this.forward(8);
    return 0;
  };

  Lexer.prototype.type = function() {
    var rmatch;
    this.forward(4);
    rmatch = (function(_this) {
      return function(bytes) {
        return match(_this.d, _this.i - 4, bytes);
      };
    })(this);
    if (rmatch(constants.byteMarker)) {
      return 'byte';
    }
    if (rmatch(constants.charMarker)) {
      return 'char';
    }
    if (rmatch(constants.shortMarker)) {
      return 'short';
    }
    if (rmatch(constants.intMarker)) {
      return 'int';
    }
    if (rmatch(constants.floatMarker)) {
      return 'float';
    }
    if (rmatch(constants.doubleMarker)) {
      return 'double';
    }
    this.backward(4);
    this.print(1);
    throw new Error('Type not found');
  };

  Lexer.prototype.chars = function(n) {
    var result;
    result = this.string(n);
    this.fill(n);
    return result;
  };

  Lexer.prototype.bytes = function(n) {
    var j, result, results;
    result = (function() {
      results = [];
      for (var j = 0; 0 <= n ? j < n : j > n; 0 <= n ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.byte();
      };
    })(this));
    this.fill(n);
    return result;
  };

  Lexer.prototype.shorts = function(n) {
    var j, result, results;
    result = (function() {
      results = [];
      for (var j = 0; 0 <= n ? j < n : j > n; 0 <= n ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.uint16();
      };
    })(this));
    this.fill(n * 2);
    return result;
  };

  Lexer.prototype.ints = function(n) {
    var j, results;
    return (function() {
      results = [];
      for (var j = 0; 0 <= n ? j < n : j > n; 0 <= n ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.uint32();
      };
    })(this));
  };

  Lexer.prototype.floats = function(n) {
    var j, results;
    return (function() {
      results = [];
      for (var j = 0; 0 <= n ? j < n : j > n; 0 <= n ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.float();
      };
    })(this));
  };

  Lexer.prototype.doubles = function(n) {
    var j, results;
    return (function() {
      results = [];
      for (var j = 0; 0 <= n ? j < n : j > n; 0 <= n ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.double();
      };
    })(this));
  };

  Lexer.prototype.reader = function(type) {
    if (this[type + "s"] == null) {
      throw new Error("A reader for " + type + " not found");
    }
    return this[type + "s"];
  };

  return Lexer;

})();
