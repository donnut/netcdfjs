// Generated by CoffeeScript 1.8.0
var Lexer, Parser, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Lexer = require('./lexer');

util = require('./util');

Parser = (function() {
  function Parser(data) {
    this.data = __bind(this.data, this);
    this["var"] = __bind(this["var"], this);
    this.var_list = __bind(this.var_list, this);
    this.attr = __bind(this.attr, this);
    this.att_list = __bind(this.att_list, this);
    this.name = __bind(this.name, this);
    this.dim = __bind(this.dim, this);
    this.dim_list = __bind(this.dim_list, this);
    this.numrecs = __bind(this.numrecs, this);
    this.magic = __bind(this.magic, this);
    this.header = __bind(this.header, this);
    this.parse = __bind(this.parse, this);
    this.fin = __bind(this.fin, this);
    this.info = __bind(this.info, this);
    this.lex = new Lexer(data);
  }

  Parser.prototype.info = function(msg) {
    return console.log(msg);
  };

  Parser.prototype.fin = function() {
    if (this.lex.hasMore()) {
      return false;
    }
    return true;
  };

  Parser.prototype.parse = function() {
    var data, header;
    header = this.header();
    data = this.data(header);
    return {
      header: header,
      data: data
    };
  };

  Parser.prototype.header = function() {
    return {
      version: this.magic(),
      records: this.numrecs(),
      dimensions: this.dim_list(),
      globalattributes: this.att_list(),
      attributes: this.att_list(),
      variables: this.var_list()
    };
  };

  Parser.prototype.magic = function() {
    var description, version;
    if (this.lex.string(3) !== 'CDF') {
      return this.error('Not a valid NetCDF file');
    }
    version = this.lex.byte();
    if (version !== 1 && version !== 2 && version !== 3) {
      return this.error("I don't know how to read NetCDF version " + version);
    }
    if (version === 1) {
      description = 'Classic format';
    }
    if (version === 2) {
      description = '64 bit offset format';
    }
    if (version === 3) {
      description = 'Version 3 - Unknown';
    }
    return {
      number: version,
      description: description
    };
  };

  Parser.prototype.numrecs = function() {
    var numrecs;
    numrecs = this.lex.bytes(4);
    if (util.test.isFFFFFFFF(numrecs)) {
      return {
        type: 'streaming'
      };
    } else {
      numrecs = util.convert.uint32(numrecs);
      return {
        type: 'fixed',
        number: numrecs
      };
    }
  };

  Parser.prototype.dim_list = function() {
    var id, num, _i, _results;
    id = this.lex.bytes(4);
    if (util.test.isZero(id)) {
      return null;
    }
    if (!util.test.isDimension(id)) {
      return this.error('Dimension identifier not found');
    }
    num = this.lex.uint32();
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= num ? _i <= num : _i >= num; 1 <= num ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.dim();
      };
    })(this));
  };

  Parser.prototype.dim = function() {
    var dim;
    dim = {
      name: this.name(),
      length: this.lex.uint32()
    };
    if (dim.length === 0) {
      dim.length = null;
    }
    return dim;
  };

  Parser.prototype.name = function() {
    var length, res;
    length = this.lex.uint32();
    res = this.lex.string(length);
    this.lex.fill(length);
    return res;
  };

  Parser.prototype.att_list = function() {
    var attr, id, num, res, _i;
    id = this.lex.bytes(4);
    if (util.test.isZero(id)) {
      return null;
    }
    if (!util.test.isAttribute(id)) {
      return this.error('Attribute identifier not found');
    }
    num = this.lex.uint32();
    res = {};
    for (_i = 1; 1 <= num ? _i <= num : _i >= num; 1 <= num ? _i++ : _i--) {
      attr = this.attr();
      res[attr.name] = attr.value;
    }
    return res;
  };

  Parser.prototype.attr = function() {
    var converter, name, num, numbytes, value;
    name = this.name();
    converter = util.convert.converter(this.lex.bytes(4));
    num = this.lex.uint32();
    numbytes = num * converter.bytes;
    value = converter.convert(this.lex.bytes(numbytes));
    this.lex.fill(numbytes);
    return {
      name: name,
      value: value
    };
  };

  Parser.prototype.var_list = function() {
    var id, num, res, variable, _i;
    id = this.lex.bytes(4);
    if (util.test.isZero(id)) {
      return null;
    }
    if (!util.test.isVariable(id)) {
      return this.error('Variable identifier not found');
    }
    num = this.lex.uint32();
    res = {};
    for (_i = 1; 1 <= num ? _i <= num : _i >= num; 1 <= num ? _i++ : _i--) {
      variable = this["var"]();
      res[variable.name] = variable.value;
    }
    return res;
  };

  Parser.prototype["var"] = function() {
    var name, num, _i, _results;
    name = this.name();
    num = this.lex.uint32();
    return {
      name: name,
      value: {
        dimensions: (function() {
          _results = [];
          for (var _i = 1; 1 <= num ? _i <= num : _i >= num; 1 <= num ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this).map((function(_this) {
          return function() {
            return _this.lex.uint32();
          };
        })(this)),
        attributes: this.att_list(),
        type: util.convert.type(this.lex.bytes(4)),
        size: this.lex.uint32(),
        offset: this.lex.uint32()
      }
    };
  };

  Parser.prototype.data = function(header) {
    return {};
  };

  return Parser;

})();

module.exports = {
  parse: function(data) {
    return new Parser(data).parse();
  },
  header: function(data) {
    return new Parser(data).header();
  },
  data: function(header, data) {
    return new Parser(data).data(header);
  }
};
